# ========== start_mark 自动校验代码（一键运行） ==========
from pytorch_transformers import BertTokenizer


def verify_start_mark(seq, start_mark):
    """
    自动校验start_mark+【新增】基于start_mark+seq反推分词结果
    :param seq: 样本的seq列表（数字ID）
    :param start_mark: 样本的start_mark列表（0/1）
    :return: dict - 校验报告 + 反推的完整分词结果
    """
    from pytorch_transformers import BertTokenizer
    tokenizer = BertTokenizer.from_pretrained("bert-base-chinese")
    # 步骤1：seq转token列表（核心前置）
    token_list = [tokenizer._convert_id_to_token(id) for id in seq]
    report = {"is_pass": True, "error_info": [], "cut_result": []}  # 新增cut_result存储分词结果

    # 校验规则1：长度必须一致
    if len(seq) != len(start_mark):
        report["is_pass"] = False
        report["error_info"].append(f"长度不一致！seq长度{len(seq)}，start_mark长度{len(start_mark)}")
        return report

    # ===================== 核心新增：基于start_mark反推分词结果 =====================
    cut_result = []  # 存储最终分词结果
    current_word = []  # 临时存储当前正在拼接的词汇

    for idx in range(len(token_list)):
        token = token_list[idx]
        sm_val = start_mark[idx]

        # 跳过特殊token [CLS]/[SEP]，不参与分词
        if token in ["[CLS]", "[SEP]"]:
            continue

        # 规则：遇到1 → 上一个词汇结束，开启新词汇
        if sm_val == 1:
            # 若临时缓存有内容，先存入最终结果
            if current_word:
                cut_result.append("".join(current_word))
                current_word = []
            # 新增当前token为新词汇的开头
            current_word.append(token)
        # 规则：遇到0 → 拼接到上一个词汇的内部
        else:
            current_word.append(token)

    # 处理最后一个未完成的词汇
    if current_word:
        cut_result.append("".join(current_word))

    report["cut_result"] = cut_result  # 将分词结果存入报告
    # ==============================================================================

    # 遍历校验核心规则（保留你原有的校验逻辑，不改动）
    for idx in range(len(token_list)):
        token = token_list[idx]
        sm_val = start_mark[idx]

        # 规则1：特殊token [CLS]/[SEP] → 必须为0
        if token in ["[CLS]", "[SEP]"]:
            if sm_val != 0:
                report["is_pass"] = False
                report["error_info"].append(f"下标{idx}：token={token}，start_mark={sm_val}（违反规则1，必须为0）")
        # 规则2：start_mark=1 → 必须是词汇开头（非##开头、非标点）
        elif sm_val == 1:
            # 排除标点/无效字符（标点标记为1属于异常）
            if token in ["，", "。", "？", "！", "：", "；", "、"]:
                report["is_pass"] = False
                report["error_info"].append(f"下标{idx}：token={token}(标点)，start_mark=1（违反规则2，标点不能标记为1）")
        # 规则3：start_mark=0 → 排除词汇开头的错误标记
        elif sm_val == 0:
            # 多字词后续token（带##）→ 0是正常的，无需校验
            if token.startswith("##"):
                continue
            # 非##、非标点、非特殊token → 需结合上下文判断（简单校验）
            if idx > 0 and token_list[idx - 1] in ["，", "。", "？", "！"] and token not in ["，", "。", "？", "！"]:
                report["is_pass"] = False
                report["error_info"].append(f"下标{idx}：token={token}(新词开头)，start_mark=0（违反规则2，应标记为1）")

    return report


# ===================== 替换成你的数据 =====================
your_seq = [101, 1585, 8024, 872, 1962, 8024, 3221, 2476, 2600, 1408, 8043, 3221, 2769, 8024, 872,
3221, 1525, 855, 8043, 1511, 8024, 2769, 3221, 1921, 2128, 7032, 6084, 704, 2552, 4638, 2207, 1155, 1557, 8024, 3297, 6818, 2769, 812, 3300,
702, 4294, 1166, 1962, 4638, 2832, 6598, 7555, 4680, 8024, 2682, 749, 6237, 671, 678, 2644, 4638, 2692, 1403, 511, 784, 720, 2832, 6598, 7555,
4680, 8043, 6821, 3221, 671, 702, 3173, 2972, 1139, 4638, 3144, 2099, 6573, 2355, 1825, 7032, 8024, 7564, 6369, 2399, 1265, 3119, 4660, 4372, 1377,
809, 6809, 1168, 4636, 1146, 722, 1282, 758, 8024, 7478, 2382, 4937, 978, 511, 6821, 720, 7770, 4638, 3119, 4660, 8043, 3221, 4638, 8024, 5445,
684, 2769, 812, 4638, 7599, 2971, 2974, 3177, 7478, 2382, 698, 3419, 8024, 5318, 2190, 2128, 1059, 511, 2644, 3300, 3198, 7313, 749, 6237, 671,
678, 1408, 8043, 2769, 3297, 6818, 2923, 2564, 4638, 8024, 679, 1922, 3300, 3198, 7313, 511, 6929, 4696, 3221, 1922, 1377, 2667, 749, 8024, 679,
6814, 3322, 833, 7410, 2533, 8024, 6206, 679, 6821, 3416, 1416, 8024, 2769, 1217, 671, 678, 2644, 4638, 2544, 928, 8024, 3300, 3198, 7313, 749,
2644, 4692, 4692, 6598, 3160, 8024, 3300, 784, 720, 7309, 7579, 1377, 809, 7390, 3198, 5468, 5143, 2769, 511, 1962, 1416, 8024, 872, 1217, 1416,
8024, 679, 6814, 2769, 2533, 2990, 7008, 872, 8024, 2769, 1217, 749, 679, 671, 2137, 833, 4692, 511, 1511, 1435, 8024, 2644, 4696, 3221, 1922,
2564, 749, 8024, 1217, 702, 2544, 928, 1416, 8024, 2769, 1373, 2207, 1155, 8024, 1168, 3198, 952, 2644, 4692, 671, 678, 8024, 3300, 784, 720,
7309, 7579, 7390, 3198, 5468, 5143, 2769, 511, 6121, 1416, 8024, 872, 1217, 1416, 511, 1962, 4638, 8024, 7478, 2382, 2697, 6468, 8024, 4867, 2644, 4495, 2692, 1069, 7384, 8024, 2769, 812, 2544, 928, 677, 5464, 511, 102]

your_start_mark =   [0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1,
 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1,
 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0,
 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0,
 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0]

# ===================== 执行校验 =====================
check_report = verify_start_mark(your_seq, your_start_mark)
print("===== start_mark 自动校验报告 =====")
if check_report["is_pass"]:
    print("✅ 校验通过！start_mark与词汇完全一一对应")
    print(check_report["cut_result"])
else:
    print("❌ 校验失败！存在以下异常：")
    for err in check_report["error_info"]:
        print(f"→ {err}")
